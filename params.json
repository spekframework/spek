{
  "name": "Spek",
  "tagline": "A specification framework for the JVM",
  "body": "### Your typical test code\r\nHere's some typical test code found in many codebases\r\n\r\n```java\r\n@Test\r\npublic void testCalculateTaxRate() {\r\n\r\n    TaxRateCalculator calculator = new TaxRateCalculator();\r\n\r\n    Int value = calculator.calculateRate(200, 10);\r\n\r\n    assertEquals(300,value);\r\n}\r\n```\r\n\r\nThis code suffers from several issues. Under what **conditions** is the tax rate calculated? What exactly is it **doing**? What is the **expected outcome**?\r\n\r\n\r\n### Being explicit with Spek\r\n\r\nSpek makes it easy to define these three important aspects without resorting to long method names or underscores:\r\n\r\n```kotlin\r\nclass SimpleTest : Spek({\r\n    describe(\"a calculator\") {\r\n        val calculator = SampleCalculator()\r\n\r\n        it(\"should return the result of adding the first number to the second number\") {\r\n            val sum = calculator.sum(2, 4)\r\n            assertEquals(6, sum)\r\n        }\r\n\r\n        it(\"should return the result of subtracting the second number from the first number\") {\r\n            val subtract = calculator.subtract(4, 2)\r\n            assertEquals(2, subtract)\r\n        }\r\n    }\r\n})\r\n```\r\n\r\n### Tests are specifications\r\n\r\nTests are executable specifications of your system. They are real-time compilable code that tell you how a piece of code should behave and under what conditions is a certain\r\noutcome expected. That is why it is important to be explicit, concise and unambiguous when it comes to defining specifications. Spek helps you do that.\r\n\r\n### Spek works with Java\r\n\r\nSpek is written in Kotlin and as such is 100% compatible with Java. You can write your specifications (notice we say specification, not test) in Kotlin and\r\nverify new or existing code written in Java or Kotlin.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}